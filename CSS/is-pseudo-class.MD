# `is()` pesudo-class

`:is()` ကို complex selector တွေကြား group matching လုပ်ဖို့ သုံးနိုင်ပါတယ်။ [^1]

ဥပမာအားဖြင့် `ol`အောက်မှာရှိတဲ့ `li` တိုင်း ၊ `ul` အောက်မှာရှိတဲ့ `li` တိုင်းကို select လုပ်မယ်ဆိုရင် ပုံမှန်ရေးနေကျအတိုင်း

        ol li,
        ul li {...}

ရေးလို့ရသလို ၊ `:is()` နဲ့လဲ ဒီလိုရေးလို့ ရပါတယ်။

        :is(ol, ul) li {...}

ပိုတောင်ရှုပ်သေးတယ်၊ နဂိုတိုင်းကမှ ရှင်းသေးတယ်ဆိုရင် ဟုတ်ပါတယ်။  ဒါပေမယ့် ဥမာအားဖြင့် two level deep မှာ ရှိတဲ့ `li` ကို select လုပ်မယ် ၊ အဲ့ဒီ `li` က- 
- `ol` အောက်က `ol` အောက်က `li` ဖြစ်လဲရတယ်။ 
- `ol` အောက်က `ul` အောက်က `li` ဖြစ်လဲရတယ်။ 
- `ul` အောက်က `ol` အောက်က `li` ဖြစ်လဲရတယ်။ 
- `ul` အောက်က `ul` အောက်က `li` ဖြစ်လဲရတယ်။ 

အဲ့လိုဆိုရင် ပုံမှန်အတိုင်းရေးဖို့ ထွေးလာပါပြီ။  

        ol ol li,
        ol ul li,
        ul ol li,
        ul ul li {...}

ဒါကို `:is()` နဲ့သာရေးမယ်ဆိုရင် 

        :is(ol, ul) :is(ol, ul) li {...}

*ဒီနေရာမှာ စာအုပ်ထဲက example[^2] ကို ကြည့်ပြီး နည်းနည်းကြောင်သွားပါတယ်။  ကျွန်တော်ပြန်လေ့ကျင့်ထားတဲ့ အတွေ့အကြုံအရ ရှုပ်လာရင် list ကို html code အတိုင်း မကြည့်ပဲ tree အနေနဲ့ ဆွဲချလိုက်ရင် ရှင်းသွားပါတယ်။*

`:is()` နဲ့ရေးထားတဲ့ အပေါ်က snippet မှာ `li` က `:is()` condition နဲ့ ညီနေတဲ့ decendent ဖြစ်နေသရွေ့ မှန်နေတာကြောင့် 2nd level မှာရှိတဲ့ `li` မှာတင် ရပ်နေမှာ မဟုတ်ပဲ ထပ်ပြီး deep ဖြစ်သွားရင်လဲ 3rd level, 4th level က `li` တွေကိုပဲ select လုပ်နေမှာပါ။

`:is()` ကို ဒီလောက်နဲ့တင်ရပ်မနေပဲ ပိုပြီး complex ဖြစ်တဲ့ situation တွေမှာလဲ သုံးလို့ရပါတယ်။  ဥပမာအားဖြင့်-
1. `header`သို့မဟုတ် `section`သို့မဟုတ် `.container` အောက်မှာရှိတဲ့
2. `ul` ဒါမှမဟုတ် `ol` အောက်မှာရှိတဲ့
3. `href` attribute ရှိတဲ့ `a` တိုင်းကို select လုပ်ချင်တယ်ဆိုရင်-


       :is(header, section, .container) :is(ul, ol) a[href] {..}

[1^]: ဒီ note က [CSS: The Definitive Guide, 5th Edition by Eric Meyer, Estelle Weyl](https://www.oreilly.com/library/view/css-the-definitive/9781098117603/) စာအုပ်ကို refer လုပ်ပြီးရေးထားတာဖြစ်ပြီး ၊ ကျွန်တော်ပြန်ဖတ်ဖို့ ကျွန်တော့ရဲ့ ကိုယ်ပိုင် study note တစ်ခုသာဖြစ်လို့ အမှားပါကောင်းပါနိုင်ပါတယ်။  
[2^]: CSS: The Definitive Guide, 5th Edition -  page 87